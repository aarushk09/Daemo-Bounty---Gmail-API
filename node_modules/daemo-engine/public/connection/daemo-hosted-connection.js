"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DaemoHostedConnection = void 0;
const proto_loader_1 = require("../utils/proto-loader");
const function_handler_1 = require("../handler/function-handler");
const grpc_manager_1 = require("./grpc-manager");
class DaemoHostedConnection {
    constructor(options, sessionData) {
        this.isConnected = false;
        this.shouldReconnect = true;
        this.reconnectTimeout = null;
        this.options = {
            daemoGatewayUrl: options.daemoGatewayUrl || "localhost:50052",
            agentApiKey: options.agentApiKey,
        };
        this.sessionData = sessionData;
        grpc_manager_1.grpcManager.configure(this.options.daemoGatewayUrl, this.options.daemoGatewayUrl);
    }
    async start() {
        if (!this.options.agentApiKey) {
            console.error("[Daemo SDK] AgentApiKey is required for hosted connection. Will not start.");
            return;
        }
        console.log("[Daemo] Starting hosted connection to", this.options.daemoGatewayUrl);
        this.shouldReconnect = true;
        this.connect();
    }
    stop() {
        console.log("[Daemo SDK] Stopping connection...");
        this.shouldReconnect = false;
        if (this.reconnectTimeout) {
            clearTimeout(this.reconnectTimeout);
            this.reconnectTimeout = null;
        }
        grpc_manager_1.grpcManager.resetClients(); // Tell manager to close channels
        this.isConnected = false;
        console.log("[Daemo SDK] Connection stopped.");
    }
    async connect() {
        if (!this.shouldReconnect || this.isConnected)
            return;
        try {
            console.log(`[Daemo SDK] Connecting to Daemo Gateway at ${this.options.daemoGatewayUrl}...`);
            const client = grpc_manager_1.grpcManager.getGatewayClient();
            this.call = client.EstablishStream();
            this.setupEventHandlers();
            this.authenticate();
        }
        catch (error) {
            console.error("[Daemo SDK] Connection failed:", error.message);
            this.handleDisconnection();
        }
    }
    setupEventHandlers() {
        this.call.on("data", (message) => this.handleGatewayMessage(message));
        this.call.on("end", () => this.handleDisconnection("Stream ended by server."));
        this.call.on("error", (error) => {
            // Ignore CANCELLED status code which happens on graceful shutdown
            if (error.code !== proto_loader_1.grpc.status.CANCELLED) {
                this.handleDisconnection(`Stream error: ${error.details || error.message}`);
            }
        });
    }
    handleDisconnection(reason = "Connection lost.") {
        if (this.isConnected) {
            this.isConnected = false;
            console.log(`[Daemo SDK] Disconnected. Reason: ${reason}`);
        }
        if (this.call) {
            this.call.removeAllListeners();
            this.call = null;
        }
        grpc_manager_1.grpcManager.resetClients();
        // Debounce reconnect logic to prevent spamming connection attempts
        if (this.shouldReconnect && !this.reconnectTimeout) {
            console.log("[Daemo SDK] Scheduling reconnect in 5 seconds...");
            this.reconnectTimeout = setTimeout(() => {
                this.reconnectTimeout = null;
                this.connect();
            }, 5000);
        }
    }
    async authenticate() {
        console.log("[Daemo SDK] Authenticating...");
        this.call.write({
            auth: { agent_api_key: this.options.agentApiKey },
        });
    }
    async registerSession() {
        console.log("[Daemo SDK] Registering session...");
        const sessionJson = JSON.stringify(this.sessionData);
        this.call.write({
            register: { session_json: sessionJson },
        });
        console.log("[Daemo SDK] Registered session...");
    }
    async handleGatewayMessage(message) {
        if (message.auth_result) {
            if (message.auth_result.success) {
                console.log(`[Daemo SDK] Authentication successful. Agent ID: ${message.auth_result.agent_id}`);
                this.isConnected = true;
                await this.registerSession();
            }
            else {
                console.error(`[Daemo SDK] Authentication failed: ${message.auth_result.message}`);
                this.stop();
            }
        }
        else if (message.function_request) {
            console.log(`[Daemo SDK] Received function request ID: ${message.function_request.request_id} for function: ${message.function_request.function_name}`);
            // Fire-and-forget to avoid blocking the stream reader
            this.handleFunctionRequest(message.function_request);
        }
        else if (message.heartbeat) {
            // The server sent us a ping. We must reply with a pong.
            console.log("[Daemo SDK] Received heartbeat from gateway. Replying...");
            this.call.write({
                heartbeat: { timestamp: Date.now().toString() }, // Use toString() for longs
            });
        }
        else {
            console.warn("[Daemo SDK] Received unknown message from gateway:", message);
        }
    }
    async handleFunctionRequest(request) {
        try {
            const handler = (0, function_handler_1.getGlobalFunctionHandler)();
            // --- FIX: Pass only the two required arguments to executeFunction ---
            const result = await handler.executeFunction(request.function_name, request.input_json);
            console.log(`[Daemo SDK] Responding to function request ID: ${request.request_id}, Success: ${result.success}`);
            this.call.write({
                function_response: {
                    request_id: request.request_id,
                    success: result.success,
                    result_json: result.resultJson,
                    error_message: result.errorMessage,
                },
            });
        }
        catch (error) {
            console.error(`[Daemo SDK] CRITICAL: Error in handleFunctionRequest for ID ${request.request_id}:`, error);
            this.call.write({
                function_response: {
                    request_id: request.request_id,
                    success: false,
                    result_json: "",
                    error_message: error.message || String(error),
                },
            });
        }
    }
    isActive() {
        return this.isConnected;
    }
}
exports.DaemoHostedConnection = DaemoHostedConnection;
