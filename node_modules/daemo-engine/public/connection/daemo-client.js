"use strict";
/**
 * DaemoClient - Client for making unary calls to Daemo Agent service
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.DaemoClient = void 0;
const results_1 = require("../types/results");
const proto_loader_1 = require("../utils/proto-loader");
const grpc_manager_1 = require("./grpc-manager");
class DaemoClient {
    createAuthMetadata() {
        const metadata = new proto_loader_1.grpc.Metadata();
        if (!this.options.agentApiKey) {
            throw new Error("AgentApiKey is not configured for DaemoClient.");
        }
        metadata.add("x-api-key", this.options.agentApiKey);
        return metadata;
    }
    constructor(options = {}) {
        this.options = {
            daemoAgentUrl: options.daemoAgentUrl || "localhost:50051",
            agentApiKey: options.agentApiKey,
        };
    }
    getClient() {
        return grpc_manager_1.grpcManager.getAgentClient();
    }
    /**
     * Process a query with the AI agent
     */
    async processQuery(query, options = {}) {
        return new Promise((resolve, reject) => {
            const request = {
                query,
                thread_id: options.threadId,
                session_id: options.sessionId,
                role: options.role,
                context_json: options.contextJson,
                analysis_mode: options.analysisMode,
            };
            if (options.llmConfig) {
                request.llm_config = {
                    provider: options.llmConfig.provider,
                    api_key: options.llmConfig.apiKey,
                    endpoint: options.llmConfig.endpoint,
                    model: options.llmConfig.model,
                    max_tokens: options.llmConfig.maxTokens,
                };
            }
            if (options.storageConfig) {
                request.storage_config = {};
                if (options.storageConfig.mongodb) {
                    request.storage_config.mongodb = {
                        connection_string: options.storageConfig.mongodb.connectionString,
                        database_name: options.storageConfig.mongodb.databaseName,
                    };
                }
                else if (options.storageConfig.localFile) {
                    request.storage_config.local_file = {
                        base_path: options.storageConfig.localFile.basePath,
                    };
                }
            }
            const metadata = this.createAuthMetadata();
            this.getClient().ProcessQuery(request, metadata, (error, response) => {
                if (error) {
                    reject(error);
                    return;
                }
                const toolInteractions = (response.tool_interactions || []).map((ti) => ({
                    toolName: ti.tool_name,
                    parametersJson: ti.parameters_json,
                    resultJson: ti.result_json,
                    success: ti.success,
                    errorMessage: ti.error_message,
                    executionTimeMs: parseInt(ti.execution_time_ms),
                }));
                resolve({
                    success: response.success,
                    response: response.response,
                    errorMessage: response.error_message,
                    threadId: response.thread_id,
                    toolInteractions,
                    executionTimeMs: parseInt(response.execution_time_ms),
                });
            });
        });
    }
    /**
     * Process a query with the AI agent streamed
     */
    processQueryStreamed(query, callbacks, options = {}) {
        const request = {
            query,
            thread_id: options.threadId,
            session_id: options.sessionId,
            role: options.role,
            context_json: options.contextJson,
            analysis_mode: options.analysisMode,
        };
        if (options.llmConfig) {
            request.llm_config = {
                provider: options.llmConfig.provider,
                api_key: options.llmConfig.apiKey,
                endpoint: options.llmConfig.endpoint,
                model: options.llmConfig.model,
                max_tokens: options.llmConfig.maxTokens,
            };
        }
        if (options.storageConfig) {
            request.storage_config = {};
            if (options.storageConfig.mongodb) {
                request.storage_config.mongodb = {
                    connection_string: options.storageConfig.mongodb.connectionString,
                    database_name: options.storageConfig.mongodb.databaseName,
                };
            }
            else if (options.storageConfig.localFile) {
                request.storage_config.local_file = {
                    base_path: options.storageConfig.localFile.basePath,
                };
            }
        }
        const metadata = this.createAuthMetadata();
        const stream = this.getClient().processQueryStreamed(request, metadata);
        const toToolCallInfo = (ti) => ({
            toolName: ti.tool_name,
            parametersJson: ti.parameters_json,
            resultJson: ti.result_json,
            success: ti.success,
            errorMessage: ti.error_message,
            executionTimeMs: parseInt(ti.execution_time_ms),
        });
        stream.on("data", (response) => {
            let event = null;
            if (response.thought) {
                event = { type: results_1.QueryStreamEventType.Thought, data: response.thought };
            }
            else if (response.tool_call) {
                event = {
                    type: results_1.QueryStreamEventType.ToolCall,
                    data: toToolCallInfo(response.tool_call),
                };
            }
            else if (response.tool_result) {
                event = {
                    type: results_1.QueryStreamEventType.ToolResult,
                    data: toToolCallInfo(response.tool_result),
                };
            }
            else if (response.partial_response_chunk) {
                event = {
                    type: results_1.QueryStreamEventType.PartialResponseChunk,
                    data: toToolCallInfo(response.partial_response_chunk),
                };
            }
            else if (response.final_response) {
                const fr = response.final_response;
                event = {
                    type: results_1.QueryStreamEventType.FinalResponse,
                    data: {
                        success: fr.success,
                        response: fr.response,
                        errorMessage: fr.error_message,
                        threadId: fr.thread_id,
                        toolInteractions: (fr.tool_interactions || []).map(toToolCallInfo),
                        executionTimeMs: parseInt(fr.execution_time_ms),
                    },
                };
            }
            else if (response.error()) {
                event = { type: results_1.QueryStreamEventType.Error, data: response.error };
            }
            if (event) {
                callbacks.onData(event);
            }
        });
        stream.on("error", (error) => callbacks.onError(error));
        stream.on("end", () => callbacks.onEnd());
        return stream;
    }
    /**
     * Create a new thread
     */
    async createThread(sessionId, storageConfig) {
        return new Promise((resolve, reject) => {
            const request = {
                session_id: sessionId,
            };
            if (storageConfig) {
                request.storage_config = {};
                if (storageConfig.mongodb) {
                    request.storage_config.mongodb = {
                        connection_string: storageConfig.mongodb.connectionString,
                        database_name: storageConfig.mongodb.databaseName,
                    };
                }
                else if (storageConfig.localFile) {
                    request.storage_config.local_file = {
                        base_path: storageConfig.localFile.basePath,
                    };
                }
            }
            this.getClient().CreateThread(request, (error, response) => {
                if (error) {
                    reject(error);
                    return;
                }
                resolve({
                    success: response.success,
                    threadId: response.thread_id,
                    errorMessage: response.error_message,
                });
            });
        });
    }
    /**
     * List all threads
     */
    async listThreads(sessionId, storageConfig) {
        return new Promise((resolve, reject) => {
            const request = {
                session_id: sessionId,
            };
            if (storageConfig) {
                request.storage_config = {};
                if (storageConfig.mongodb) {
                    request.storage_config.mongodb = {
                        connection_string: storageConfig.mongodb.connectionString,
                        database_name: storageConfig.mongodb.databaseName,
                    };
                }
                else if (storageConfig.localFile) {
                    request.storage_config.local_file = {
                        base_path: storageConfig.localFile.basePath,
                    };
                }
            }
            this.getClient().ListThreads(request, (error, response) => {
                if (error) {
                    reject(error);
                    return;
                }
                const threads = (response.threads || []).map((t) => ({
                    threadId: t.thread_id,
                    createdAt: new Date(t.created_at),
                    updatedAt: new Date(t.updated_at),
                    messageCount: t.message_count,
                    dataCount: t.data_count,
                    memorySizeBytes: parseInt(t.memory_size_bytes),
                    sessionId: t.session_id,
                    lastUserMessage: t.last_user_message,
                }));
                resolve({
                    success: response.success,
                    threads,
                    errorMessage: response.error_message,
                });
            });
        });
    }
    /**
     * Get a specific thread
     */
    async getThread(threadId, storageConfig) {
        return new Promise((resolve, reject) => {
            const request = {
                thread_id: threadId,
            };
            if (storageConfig) {
                request.storage_config = {};
                if (storageConfig.mongodb) {
                    request.storage_config.mongodb = {
                        connection_string: storageConfig.mongodb.connectionString,
                        database_name: storageConfig.mongodb.databaseName,
                    };
                }
                else if (storageConfig.localFile) {
                    request.storage_config.local_file = {
                        base_path: storageConfig.localFile.basePath,
                    };
                }
            }
            this.getClient().GetThread(request, (error, response) => {
                if (error) {
                    reject(error);
                    return;
                }
                let thread;
                if (response.thread_info) {
                    thread = {
                        threadId: response.thread_info.thread_id,
                        createdAt: new Date(response.thread_info.created_at),
                        updatedAt: new Date(response.thread_info.updated_at),
                        messageCount: response.thread_info.message_count,
                        dataCount: response.thread_info.data_count,
                        memorySizeBytes: parseInt(response.thread_info.memory_size_bytes),
                        sessionId: response.thread_info.session_id,
                        lastUserMessage: response.thread_info.last_user_message,
                    };
                }
                const recentMessages = (response.recent_messages || []).map((m) => ({
                    id: m.id,
                    timestamp: new Date(m.timestamp),
                    role: m.role,
                    content: m.content,
                }));
                resolve({
                    success: response.success,
                    thread,
                    recentMessages,
                    errorMessage: response.error_message,
                });
            });
        });
    }
    /**
     * Delete a thread
     */
    async deleteThread(threadId, storageConfig) {
        return new Promise((resolve, reject) => {
            const request = {
                thread_id: threadId,
            };
            if (storageConfig) {
                request.storage_config = {};
                if (storageConfig.mongodb) {
                    request.storage_config.mongodb = {
                        connection_string: storageConfig.mongodb.connectionString,
                        database_name: storageConfig.mongodb.databaseName,
                    };
                }
                else if (storageConfig.localFile) {
                    request.storage_config.local_file = {
                        base_path: storageConfig.localFile.basePath,
                    };
                }
            }
            this.getClient().DeleteThread(request, (error, response) => {
                if (error) {
                    reject(error);
                    return;
                }
                resolve({
                    success: response.success,
                    errorMessage: response.error_message,
                });
            });
        });
    }
}
exports.DaemoClient = DaemoClient;
