"use strict";
/**
 * Diagnostic Script for Daemo Node SDK Metadata Issues
 *
 * Run this script to verify that TypeScript decorator metadata is being emitted correctly.
 *
 * Usage: ts-node diagnostic.ts
 */
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
require("reflect-metadata");
// Test decorator
function TestDecorator() {
    return (target, propertyKey, descriptor) => {
        console.log(`\n=== Decorator called for method: ${String(propertyKey)} ===`);
        return descriptor;
    };
}
// Test class with various method signatures
class TestClass {
    simpleMethod(name, age) {
        return `${name} is ${age}`;
    }
    async asyncMethod(id) {
        return { id, data: {} };
    }
    optionalParamsMethod(required, optional) { }
    noParamsMethod() {
        return true;
    }
}
__decorate([
    TestDecorator(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Number]),
    __metadata("design:returntype", String)
], TestClass.prototype, "simpleMethod", null);
__decorate([
    TestDecorator(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], TestClass.prototype, "asyncMethod", null);
__decorate([
    TestDecorator(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Number]),
    __metadata("design:returntype", void 0)
], TestClass.prototype, "optionalParamsMethod", null);
__decorate([
    TestDecorator(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Boolean)
], TestClass.prototype, "noParamsMethod", null);
console.log("=== Daemo SDK Metadata Diagnostics ===\n");
// Check if reflect-metadata is loaded
console.log("✓ reflect-metadata imported successfully");
const prototype = TestClass.prototype;
const methodNames = [
    "simpleMethod",
    "asyncMethod",
    "optionalParamsMethod",
    "noParamsMethod",
];
console.log("\n=== Testing Metadata Extraction ===\n");
for (const methodName of methodNames) {
    console.log(`\nMethod: ${methodName}`);
    console.log("─".repeat(50));
    // Test parameter types
    const paramTypes = Reflect.getMetadata("design:paramtypes", prototype, methodName);
    console.log("Parameter types:", paramTypes);
    if (paramTypes && paramTypes.length > 0) {
        console.log("  ✓ Parameters detected:");
        paramTypes.forEach((type, index) => {
            console.log(`    [${index}] ${type.name || type}`);
        });
    }
    else {
        console.log("  ✗ NO PARAMETERS DETECTED - This is the problem!");
    }
    // Test return type
    const returnType = Reflect.getMetadata("design:returntype", prototype, methodName);
    console.log("Return type:", returnType);
    if (returnType) {
        console.log(`  ✓ Return type: ${returnType.name || returnType}`);
    }
    else {
        console.log("  ✗ NO RETURN TYPE DETECTED - This is a problem!");
    }
    // Test with bound method (simulating what SDK does)
    const instance = new TestClass();
    const boundMethod = instance[methodName].bind(instance);
    console.log("\nTesting with bound method (what SDK does):");
    const boundParamTypes = Reflect.getMetadata("design:paramtypes", boundMethod);
    const boundReturnType = Reflect.getMetadata("design:returntype", boundMethod);
    console.log("  Bound method param types:", boundParamTypes || "undefined ✗");
    console.log("  Bound method return type:", boundReturnType || "undefined ✗");
    if (!boundParamTypes && !boundReturnType) {
        console.log("  ⚠ Metadata NOT available on bound function (expected)");
        console.log("  ℹ This is why we must read from prototype with method name!");
    }
}
console.log("\n\n=== Configuration Check ===\n");
try {
    const fs = require("fs");
    const path = require("path");
    const tsconfigPath = path.join(process.cwd(), "tsconfig.json");
    if (fs.existsSync(tsconfigPath)) {
        const tsconfig = JSON.parse(fs.readFileSync(tsconfigPath, "utf8"));
        const compilerOptions = tsconfig.compilerOptions || {};
        console.log("tsconfig.json found:");
        console.log(`  experimentalDecorators: ${compilerOptions.experimentalDecorators}`);
        console.log(`  emitDecoratorMetadata: ${compilerOptions.emitDecoratorMetadata}`);
        if (!compilerOptions.experimentalDecorators) {
            console.log("\n  ✗ ERROR: experimentalDecorators is not enabled!");
            console.log("  Add this to tsconfig.json compilerOptions:");
            console.log('    "experimentalDecorators": true');
        }
        if (!compilerOptions.emitDecoratorMetadata) {
            console.log("\n  ✗ ERROR: emitDecoratorMetadata is not enabled!");
            console.log("  Add this to tsconfig.json compilerOptions:");
            console.log('    "emitDecoratorMetadata": true');
        }
        if (compilerOptions.experimentalDecorators &&
            compilerOptions.emitDecoratorMetadata) {
            console.log("\n  ✓ TypeScript configuration looks correct!");
        }
    }
    else {
        console.log("✗ tsconfig.json not found in current directory");
    }
}
catch (error) {
    console.log("Could not read tsconfig.json:", error);
}
console.log("\n=== Summary ===\n");
console.log("If you see 'NO PARAMETERS DETECTED' or 'NO RETURN TYPE DETECTED' above,");
console.log("then your TypeScript configuration is not emitting decorator metadata.");
console.log("\nRequired tsconfig.json settings:");
console.log("{");
console.log('  "compilerOptions": {');
console.log('    "experimentalDecorators": true,');
console.log('    "emitDecoratorMetadata": true,');
console.log('    "target": "ES2017" // or higher');
console.log("  }");
console.log("}");
console.log("\nAfter fixing tsconfig.json, rebuild your project completely:");
console.log("  rm -rf dist/");
console.log("  npm run build");
