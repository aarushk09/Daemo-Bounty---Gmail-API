"use strict";
// ./daemo-sdk-node/src/decorators/daemo-function.ts
Object.defineProperty(exports, "__esModule", { value: true });
exports.DaemoSchema = DaemoSchema;
exports.getDaemoSchema = getDaemoSchema;
exports.DaemoFunction = DaemoFunction;
exports.ParameterDescription = ParameterDescription;
exports.FromDaemoContext = FromDaemoContext;
exports.getDaemoFunctionMetadata = getDaemoFunctionMetadata;
exports.getParameterDescriptions = getParameterDescriptions;
exports.hasDaemoFunction = hasDaemoFunction;
exports.getDaemoFunctions = getDaemoFunctions;
require("reflect-metadata");
// --- NEW: Schema Decorator and Types ---
const DAEMO_SCHEMA_KEY = Symbol("daemoSchema");
/**
 * Decorator to attach a detailed, explicit schema to a class.
 * This schema is used for generating the function interface for the AI agent.
 * @param schema The detailed definition of the class properties.
 */
function DaemoSchema(schema) {
    return (target) => {
        Reflect.defineMetadata(DAEMO_SCHEMA_KEY, schema, target);
    };
}
/**
 * Retrieves the schema definition attached to a class by the @DaemoSchema decorator.
 */
function getDaemoSchema(target) {
    return Reflect.getMetadata(DAEMO_SCHEMA_KEY, target);
}
// --- EXISTING DECORATORS ---
const DAEMO_FUNCTION_KEY = Symbol("daemoFunction");
const DAEMO_PARAMETER_KEY = Symbol("daemoParameter");
/**
 * Decorator to mark a method as a Daemo function
 * @param metadata Function metadata including description, examples, tags, etc.
 */
function DaemoFunction(metadata = {}) {
    return (target, propertyKey, descriptor) => {
        Reflect.defineMetadata(DAEMO_FUNCTION_KEY, metadata, target, propertyKey);
        return descriptor;
    };
}
/**
 * Decorator to add description to a parameter
 * @param description Parameter description
 */
function ParameterDescription(description) {
    return (target, propertyKey, parameterIndex) => {
        const existingParameters = Reflect.getMetadata(DAEMO_PARAMETER_KEY, target, propertyKey) ||
            new Map();
        existingParameters.set(parameterIndex, description);
        Reflect.defineMetadata(DAEMO_PARAMETER_KEY, existingParameters, target, propertyKey);
    };
}
/**
 * Decorator to mark a parameter for context injection
 * @param key The context key to inject
 */
function FromDaemoContext(key) {
    return (target, propertyKey, parameterIndex) => {
        const contextKey = `${String(propertyKey)}_context_${parameterIndex}`;
        Reflect.defineMetadata(contextKey, key, target);
    };
}
/**
 * Get function metadata from a method
 */
function getDaemoFunctionMetadata(target, propertyKey) {
    return Reflect.getMetadata(DAEMO_FUNCTION_KEY, target, propertyKey);
}
/**
 * Get parameter descriptions from a method
 */
function getParameterDescriptions(target, propertyKey) {
    return (Reflect.getMetadata(DAEMO_PARAMETER_KEY, target, propertyKey) || new Map());
}
/**
 * Check if a method has the DaemoFunction decorator
 */
function hasDaemoFunction(target, propertyKey) {
    return Reflect.hasMetadata(DAEMO_FUNCTION_KEY, target, propertyKey);
}
/**
 * Get all methods with DaemoFunction decorator from a class
 */
function getDaemoFunctions(target) {
    const prototype = target.prototype || target;
    const methods = [];
    for (const propertyKey of Object.getOwnPropertyNames(prototype)) {
        if (propertyKey === "constructor")
            continue;
        const descriptor = Object.getOwnPropertyDescriptor(prototype, propertyKey);
        if (descriptor && typeof descriptor.value === "function") {
            if (hasDaemoFunction(prototype, propertyKey)) {
                methods.push(propertyKey);
            }
        }
    }
    return methods;
}
