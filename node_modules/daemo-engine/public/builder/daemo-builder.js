"use strict";
/**
 * DaemoBuilder - COMPLETELY FIXED VERSION
 * - Fixes parameter metadata extraction
 * - Adds explicit return type support
 * - Removes unused typeDefinitions
 * - Supports array element types
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DaemoBuilder = void 0;
require("reflect-metadata");
const daemo_function_1 = require("../decorators/daemo-function");
const type_utils_1 = require("../utils/type-utils");
const function_handler_1 = require("../handler/function-handler");
const zod_to_json_schema_1 = __importDefault(require("zod-to-json-schema"));
class DaemoBuilder {
    constructor() {
        this.serviceName = "MyService";
        this.systemPrompt = "";
        this.functions = [];
    }
    /**
     * Set the service name
     */
    withServiceName(serviceName) {
        if (!serviceName || serviceName.trim() === "")
            throw new Error("Service name cannot be null or empty");
        if (!(0, type_utils_1.isValidTypeScriptIdentifier)(serviceName))
            throw new Error(`Service name '${serviceName}' is not a valid TypeScript identifier`);
        this.serviceName = serviceName;
        return this;
    }
    /**
     * Set the system prompt
     */
    withSystemPrompt(systemPrompt) {
        this.systemPrompt = systemPrompt;
        return this;
    }
    /**
     * Register all methods from a service class
     */
    registerService(serviceInstance, namePrefix = "") {
        const servicePrototype = serviceInstance.constructor.prototype;
        const methods = (0, daemo_function_1.getDaemoFunctions)(serviceInstance.constructor);
        for (const methodName of methods) {
            const functionName = namePrefix
                ? `${namePrefix}${methodName.charAt(0).toUpperCase() + methodName.slice(1)}`
                : (0, type_utils_1.toCamelCase)(methodName);
            const method = serviceInstance[methodName];
            const boundMethod = method.bind(serviceInstance);
            const metadata = (0, daemo_function_1.getDaemoFunctionMetadata)(servicePrototype, methodName) || {};
            if (!metadata.inputSchema || !metadata.outputSchema) {
                throw new Error(`DaemoFunction '${methodName}' is missing required 'inputSchema' or 'outputSchema' in its decorator.`);
            }
            const func = {
                name: functionName,
                handler: boundMethod,
                description: metadata.description || "",
                tags: metadata.tags || [],
                examples: metadata.examples || [],
                category: metadata.category || "",
                roles: metadata.roles || [],
                inputSchema: metadata.inputSchema,
                outputSchema: metadata.outputSchema,
            };
            this.functions.push(func);
            // --- FIX: Use the correct method name 'registerDaemoFunction' ---
            (0, function_handler_1.getGlobalFunctionHandler)().registerDaemoFunction(func);
            console.log(`[Daemo SDK] âœ“ Registered decorated function: ${functionName}`);
        }
        return this;
    }
    /**
     * Build and return the session data
     */
    build() {
        const sessionData = {
            Port: 0,
            ServiceName: this.serviceName,
            SystemPrompt: this.systemPrompt,
            Functions: this.functions.map((func) => {
                // --- FIX: Cast the result of zodToJsonSchema to our defined type ---
                const inputJsonSchema = (0, zod_to_json_schema_1.default)(func.inputSchema, {
                    target: "openApi3",
                });
                const outputJsonSchema = (0, zod_to_json_schema_1.default)(func.outputSchema, {
                    target: "openApi3",
                });
                const parameters = Object.entries(inputJsonSchema.properties || {}).map(([name, schema]) => ({
                    name,
                    description: schema.description || "",
                    schema: schema,
                    required: inputJsonSchema.required?.includes(name) || false,
                    defaultValue: schema.default,
                    examples: [],
                }));
                return {
                    Name: func.name,
                    Description: func.description,
                    Examples: [], // Can be added to decorator metadata later
                    Tags: func.tags,
                    Category: func.category || "",
                    ReturnDescription: outputJsonSchema.description || "",
                    Roles: func.roles || [],
                    Parameters: parameters,
                    ReturnType: outputJsonSchema,
                };
            }),
            Definitions: {}, // Not needed as zod-to-json-schema creates self-contained schemas
        };
        return sessionData;
    }
}
exports.DaemoBuilder = DaemoBuilder;
