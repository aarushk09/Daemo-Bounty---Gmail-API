"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateSchema = generateSchema;
exports.discoverTypes = discoverTypes;
exports.buildDefinitions = buildDefinitions;
require("reflect-metadata");
const daemo_function_1 = require("../decorators/daemo-function");
/**
 * Builds a full JSON Schema from a class decorated with @DaemoSchema.
 * This is the core function that translates the developer-friendly schema into a valid JSON Schema.
 */
function buildSchemaFromDecorator(type) {
    const schemaDef = (0, daemo_function_1.getDaemoSchema)(type);
    if (!schemaDef)
        return null;
    const schema = {
        type: "object",
        title: type.name,
        description: schemaDef.description || `Schema for ${type.name}`,
        properties: {},
        required: [],
    };
    for (const [key, prop] of Object.entries(schemaDef.properties)) {
        const propType = Reflect.getMetadata("design:type", type.prototype, key);
        const propSchema = { description: prop.description };
        if (prop.type === "array") {
            propSchema.type = "array";
            // We assume `items` refers to another decorated DTO.
            // The `arrayElementType` on `@DaemoFunction` is the primary way to specify array types.
            // This part handles arrays of primitives defined inside a @DaemoSchema.
            if (prop.items) {
                propSchema.items = {
                    type: prop.items.type,
                    description: prop.items.description,
                };
            }
        }
        else if (prop.type === "object" && propType && (0, daemo_function_1.getDaemoSchema)(propType)) {
            // If the property is an object AND its type is another decorated DTO, create a reference.
            propSchema["$ref"] = `#/definitions/${propType.name}`;
        }
        else {
            // Handle primitives or inline objects
            propSchema.type = prop.type;
            if (prop.format) {
                propSchema.format = prop.format;
            }
            if (prop.properties) {
                // This handles simple, non-referential inline objects.
                propSchema.properties = Object.fromEntries(Object.entries(prop.properties).map(([k, v]) => [
                    k,
                    { type: v.type, description: v.description },
                ]));
            }
        }
        schema.properties[key] = propSchema;
        if (prop.required) {
            schema.required.push(key);
        }
    }
    if (schema.required.length === 0) {
        delete schema.required;
    }
    return schema;
}
/**
 * Generates a JSON schema reference for a TypeScript type.
 * If the type is decorated, it returns a $ref. Otherwise, it returns a primitive type.
 */
function generateSchema(type, definitions) {
    if (!type)
        return { title: "any" };
    // If it's a decorated DTO, always use a reference.
    if ((0, daemo_function_1.getDaemoSchema)(type)) {
        return { $ref: `#/definitions/${type.name}` };
    }
    // Fallback for primitives and built-in types.
    if (type === String)
        return { type: "string", title: "string" };
    if (type === Number)
        return { type: "number", title: "number" };
    if (type === Boolean)
        return { type: "boolean", title: "boolean" };
    if (type === Date)
        return { type: "string", format: "date-time", title: "Date" };
    if (type === Promise || type.name === "Promise")
        return { title: "Promise<any>" };
    if (type === Array)
        return { type: "array", items: { title: "any" }, title: "any[]" };
    if (type === Object)
        return { type: "object", title: "any" };
    return { title: "any" };
}
/**
 * Recursively discovers all classes decorated with @DaemoSchema from a starting type.
 */
function discoverTypes(type, discovered) {
    if (!type || typeof type !== "function" || discovered.has(type)) {
        return;
    }
    const schemaDef = (0, daemo_function_1.getDaemoSchema)(type);
    if (!schemaDef) {
        return; // Only process decorated types
    }
    discovered.add(type);
    // Introspect properties to find more decorated types
    for (const key of Object.keys(schemaDef.properties)) {
        if (type.prototype) {
            const propType = Reflect.getMetadata("design:type", type.prototype, key);
            if (propType) {
                discoverTypes(propType, discovered);
            }
        }
    }
}
/**
 * Builds the complete `definitions` map for the SessionData object.
 */
function buildDefinitions(types) {
    const definitions = {};
    const sortedTypes = Array.from(types).sort((a, b) => (a.name || "").localeCompare(b.name || ""));
    for (const type of sortedTypes) {
        const schema = buildSchemaFromDecorator(type);
        if (schema) {
            definitions[type.name] = schema;
        }
    }
    return definitions;
}
